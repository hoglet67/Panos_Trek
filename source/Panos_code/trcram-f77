      SUBROUTINE CRAM(HM,LEN)
      COMMON/PRLUN/LUN
      COMMON/CHARCOMN/NULL,BLANK
      CHARACTER NULL,BLANK
      INTEGER HM(30)
      INTEGER HLINE(30)
      INTEGER LEN
C--------<M> IS AN ARRAY CONTAINING CHARACTERS LJZF.  BYTES ARE PUT
C--------INTO THE OUTPUT BUFFER UP TO THE FIRST 00B BYTE.
C     BYTE LINE(120)
      CHARACTER LINE(120),M(120),KHAR
      LOGICAL FIRSTIME
      DATA FIRSTIME/.TRUE./
C     DATA LINE/120*0/,ICH/1/
      DATA ICH/1/
      IF(.NOT. FIRSTIME) GO TO 1
      DO 120 L=1,120
 120  LINE(L)=BLANK
      FIRSTIME=.FALSE.
 1    K=80
      DO 2 I=1,120
      M(I)=NULL
 2    CONTINUE
      CALL HUNPAK(HM(1),M(1),LEN)
      GO TO 11
C*
      ENTRY CRAMS(HM,LEN,IK)
C*
      K=IK
      DO 102 I=1,120
      M(I)=NULL
 102  CONTINUE
      CALL HUNPAK(HM(1),M(1),LEN)
 11   IDUMP=0
 5    ICHX=0
C--------GET THE NEXT CHARACTER OF <M>
 10   ICHX=ICHX+1
      IF (ICHX.GT.K) GOTO 21
      KHAR=M(ICHX)
C--------PUT IT IN BUFFER
      IF(KHAR .EQ. NULL) GO TO 21
      LINE(ICH)=KHAR
      ICH=ICH+1
      IF(ICH.GT.120) GOTO 25
      IF((ICH.GT.72).AND.(LUN.EQ.1)) GOTO 25
      GO TO 10
C*
      ENTRY CRENDNO
C--------DUMP BUFFER AND SUPPRESS LINE FEED
      CALL HPACK(LINE(1),HLINE(1),ICH)
      CALL PROMPT (HLINE,ICH)
      GOTO 27
C*
      ENTRY CRAMDMP (HM,LEN)
C--------INSERT FINAL ENTRY AND DUMP BUFFER
      K=80
      DO 202 I=1,120
      M(I)=NULL
 202  CONTINUE
      CALL HUNPAK(HM(1),M(1),LEN)
      GO TO 22
C*
      ENTRY CRMDPS(HM,LEN,IK)
      K=IK
      DO 302 I=1,120
      M(I)=NULL
 302  CONTINUE
      CALL HUNPAK(HM(1),M(1),LEN)
 22   IDUMP=1
      GO TO 5
 21   IF(IDUMP.EQ. 0) RETURN
C
      ENTRY CREND
C--------DUMP BUFFER AND GO TO NEW LINE
 25   CALL HPACK(LINE(1),HLINE(1),ICH)
      CALL PROUT(HLINE,ICH)
C27   DO 30 L=1,ICH
C30   LINE(L)=0
 27   DO 30 L=1,120
 30   LINE(L)=BLANK
      ICH=1
      RETURN
      END
C
      SUBROUTINE CRAMF(XX,W,D)
      COMMON/CHARCOMN/NULL,BLANK
      CHARACTER NULL,BLANK
      COMMON/ZERO/IZERO
C     BYTE CF(10),CS(10)
      CHARACTER CF(10),CS(10)
      INTEGER HCS(3)
C     INTEGER*4 I
      INTEGER I
      INTEGER W,D
      NEG=0
      DO 5 N=1,10
C 5   CF(N)=0
  5   CF(N)=NULL
      X=XX
      IF(X .GE. 0) GO TO 10
      X=-XX
      NEG=1
 10   N=0
      IF(D .EQ. 0) GO TO 30
C--------CONVERT FRACTIONAL PART TO ASCII
      I=X*10**D+.5
      DO 20 N=1,D
      J=MOD(I,10)
C     CF(N)=1H0+J
      CF(N)=CHAR(IZERO+J)
 20   I=I/10
C--------INSERT DECIMAL POINT
      N=D+1
C     CF(N)=1H.
      CALL HUNPAK(1H.,CF(N),1)
C--------CONVERT INTEGRAL PART TO ASCII
 30   J=MOD(I,10)
      N=N+1
C     CF(N)=1H0+J
      CF(N)=CHAR(IZERO+J)
      I=I/10
      IF(I .NE. 0) GO TO 30
C--------INSERT MINUS SIGN IF NEEDED
      IF(NEG .EQ. 0) GO TO 40
      N=N+1
C     CF(N)=1H-
      CALL HUNPAK(1H-,CF(N),1)
C--------PAD WITH BLANKS TO TOTAL OF <W> CHARACTERS
 40   IF(N .GE. W .OR. N .GE. 9) GO TO 43
      N=N+1
      CF(N)=BLANK
      GO TO 40
 43   DO 45 I=1,N
 45   CS(I)=CF(N-I+1)
C     CS(N+1)=0
C50   CALL CRAM(CS)
 50   CALL HPACK(CS(1),HCS(1),N)
      CALL CRAM(HCS(1),N)
      RETURN
      END
C
      SUBROUTINE CRAMI(II,W)
      COMMON/CHARCOMN/NULL,BLANK
      CHARACTER NULL,BLANK
      COMMON/ZERO/IZERO
C     BYTE CI(10),CS(10)
      CHARACTER CI(10),CS(10)
      INTEGER HCS(3)
      INTEGER W
      I=II
      NEG=0
      IF(I .GE. 0) GO TO 10
      I=-II
      NEG=1
C--------CONVERT THE NUMBER ITSELF TO ASCII
 10   DO 15 N=1,10
C15   CI(N)=0
 15   CI(N)=NULL
      N=0
 20   J=MOD(I,10)
      N=N+1
C     CI(N)=1H0+J
      CI(N)=CHAR(IZERO+J)
      I=I/10
      IF(I .NE. 0) GO TO 20
C--------INSERT MINUS SIGN IF NEEDED
 30   IF(NEG .EQ. 0) GO TO 40
      N=N+1
C     CI(N)=1H-
      CALL HUNPAK(1H-,CI(N),1)
C--------PAD WITH BLANKS TO TOTAL OF <W> CHARACTERS
 40   IF(N .GE. W .OR. N .GE. 9) GO TO 43
      N=N+1
      CI(N)=BLANK
      GO TO 40
 43   DO 45 I=1,N
 45   CS(I)=CI(N-I+1)
C     CS(N+1)=0
C     CALL CRAM(CS)
      CALL HPACK(CS(1),HCS(1),N)
      CALL CRAM(HCS(1),N)
      RETURN
      END
